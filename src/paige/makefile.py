import re
from typing import List, Dict, Any, Union

from paige.namespace import get_namespace_name, get_namespace_metadata


class Makefile:
    def __init__(
        self,
        path: str,
        default_target: str = None,
        namespace: Union[str, object] = None,
    ):
        self.path = path
        self.default_target = default_target
        self.namespace = namespace

    def get_namespace_name(self):
        return get_namespace_name(self.namespace)

    def get_default_target_name(self):
        if self.default_target is None:
            return ""
        return str(self.default_target)


def to_make_target(str_name: str) -> str:
    """Convert input to make target format (kebab-case)."""
    output = str_name
    if ":" in str_name:
        output = str_name.split(":")[1]

    # Convert to kebab-case
    output = re.sub(r"([a-z0-9])([A-Z])", r"\1-\2", output)
    return output.lower().replace("_", "-")


def to_make_vars(args: List[str]) -> List[str]:
    """Convert function arguments to make variables."""
    make_vars = []
    for arg in args:
        # Convert to snake_case
        arg = re.sub(r"([a-z0-9])([A-Z])", r"\1_\2", arg).lower()
        make_vars.append(arg)
    return make_vars


def to_paige_function(target: str, args: List[str]) -> str:
    """Convert input to a paige target name with the provided args."""
    result = target
    for arg in args:
        result += f' "$({arg})"'
    return result


def should_be_generated(makefiles: List[Makefile], namespace: str) -> tuple[bool, str]:
    """Returns true if the namespace equals any of the namespaces in the to be generated Makefiles and
    returns any metadata the namespace might have."""
    part_of_makefile = False
    namespace_struct = "{"

    for mk in makefiles:
        if mk.get_namespace_name() == namespace:
            part_of_makefile = True
            metadata = get_namespace_metadata(mk.namespace)

            for key, value in metadata.items():
                namespace_struct += f"\n{key}:"
                if isinstance(value, str):
                    namespace_struct += f' "{value}",'
                else:
                    namespace_struct += f" {value},"

    namespace_struct += "}."
    return part_of_makefile, namespace_struct


def generate_makefile_content(
    makefile: Makefile,
    functions: Dict[str, List[Dict[str, Any]]],
    executable_path: str,
    all_makefiles: List[Makefile] = None,
) -> str:
    """Generate Makefile content for a specific Makefile configuration."""
    lines = []

    # Header
    lines.append("# Generated by Paige - Python build tool inspired by Sage")
    lines.append("# To learn more, see .paige/paigefile.py")
    lines.append("")

    # Set default target if specified
    if makefile.default_target:
        lines.append(f".DEFAULT_GOAL := {makefile.default_target}")
        lines.append("")

    # Setup Python environment
    lines.append("cwd := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))")
    lines.append("paige_dir := $(abspath $(cwd)/.paige)")
    lines.append("paige_venv := $(paige_dir)/.venv")
    lines.append("python := $(paige_venv)/bin/python")
    lines.append("paige_binary := $(paige_dir)/bin/paigefile")
    lines.append("")

    # Python setup
    lines.append("# Setup Python environment")
    lines.append("$(python):")
    lines.append("\t@echo 'Setting up Paige Python environment...'")
    lines.append("\t@cd $(paige_dir) && uv sync --active")
    lines.append("")

    # Main paige target
    lines.append(".PHONY: paige")
    lines.append("paige: $(python)")
    lines.append("\t@cd $(paige_dir) && $(python) paigefile.py")
    lines.append("")

    # Update paige target
    lines.append(".PHONY: update-paige")
    lines.append("update-paige: $(python)")
    lines.append(
        "\t@cd $(paige_dir) && uv pip install --upgrade git+https://github.com/TheodorEmanuelsson/paige.git"
    )
    lines.append("\t@cd $(paige_dir) && uv sync --active")
    lines.append("")

    # Clean paige target
    lines.append(".PHONY: clean-paige")
    lines.append("clean-paige:")
    lines.append("\t@rm -rf $(paige_dir)/.venv")
    lines.append("\t@rm -rf $(paige_dir)/__pycache__")
    lines.append("\t@rm -rf $(paige_dir)/bin")
    lines.append("")

    # Rule to create the binary when needed
    lines.append("$(paige_binary):")
    lines.append("\tpython -m paige.generate")
    lines.append("")

    # Generate targets for functions
    namespace = makefile.get_namespace_name()

    for module_name, module_functions in functions.items():
        for func in module_functions:
            # Check if this function belongs to this namespace
            if namespace:
                # For now, we'll assume functions in the module belong to the namespace
                # TODO: Implement proper namespace detection from AST
                pass
            else:
                # Main namespace - include all functions
                pass

            target_name = to_make_target(func["name"])
            parameters = func["args"][1:]  # Skip context parameter
            make_vars = to_make_vars(parameters)

            lines.append(f".PHONY: {target_name}")
            lines.append(f"{target_name}: $(paige_binary)")

            # Add parameter validation
            for var in make_vars:
                lines.append(f"ifndef {var}")
                lines.append(f'\t$(error missing argument {var}="...")')
                lines.append("endif")

            # Build the command
            cmd_parts = ["@cd $(paige_dir) && ./bin/paigefile"]
            cmd_parts.append(f"{func['name']}")

            # Add parameters
            for var in make_vars:
                cmd_parts.append(f'"$({var})"')

            lines.append("\t" + " ".join(cmd_parts))
            lines.append("")

    # Add sub-makefiles for other namespaces
    if not namespace and all_makefiles:
        # This is the main Makefile, add targets for other namespaces
        for mk in all_makefiles:
            if mk.get_namespace_name():
                ns_target = mk.get_namespace_name().lower().replace("_", "-")
                lines.append(f".PHONY: {ns_target}")
                lines.append(f"{ns_target}:")
                lines.append(f"\t$(MAKE) -f {mk.path}")
                lines.append("")

    return "\n".join(lines)
